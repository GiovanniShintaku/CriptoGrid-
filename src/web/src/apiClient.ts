//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    publicDataGET(id: string): Promise<CoinData> {
        let url_ = this.baseUrl + "/api/PublicData/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPublicDataGET(_response);
        });
    }

    protected processPublicDataGET(response: Response): Promise<CoinData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoinData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CoinData>(null as any);
    }

    /**
     * @return OK
     */
    publicDataDELETE(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/PublicData/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPublicDataDELETE(_response);
        });
    }

    protected processPublicDataDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param timeframe (optional) 
     * @return OK
     */
    history(coinId: string, timeframe: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/PublicData/{coinId}/history?";
        if (coinId === undefined || coinId === null)
            throw new globalThis.Error("The parameter 'coinId' must be defined.");
        url_ = url_.replace("{coinId}", encodeURIComponent("" + coinId));
        if (timeframe === null)
            throw new globalThis.Error("The parameter 'timeframe' cannot be null.");
        else if (timeframe !== undefined)
            url_ += "timeframe=" + encodeURIComponent("" + timeframe) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHistory(_response);
        });
    }

    protected processHistory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    publicDataPOST(body: CoinData | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/PublicData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPublicDataPOST(_response);
        });
    }

    protected processPublicDataPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    publicDataPUT(id: string, body: CoinData | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/PublicData/{Id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPublicDataPUT(_response);
        });
    }

    protected processPublicDataPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    userAuthGET(id: string): Promise<UserAuthData> {
        let url_ = this.baseUrl + "/api/UserAuth/{Id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserAuthGET(_response);
        });
    }

    protected processUserAuthGET(response: Response): Promise<UserAuthData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAuthData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserAuthData>(null as any);
    }

    /**
     * @return OK
     */
    userAuthDELETE(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/UserAuth/{Id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserAuthDELETE(_response);
        });
    }

    protected processUserAuthDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    userAuthPOST(body: UserAuthData | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserAuth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserAuthPOST(_response);
        });
    }

    protected processUserAuthPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    userCoinsDataGET(id: string): Promise<UserCoinsData> {
        let url_ = this.baseUrl + "/api/UserCoinsData/{Id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserCoinsDataGET(_response);
        });
    }

    protected processUserCoinsDataGET(response: Response): Promise<UserCoinsData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserCoinsData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserCoinsData>(null as any);
    }

    /**
     * @return OK
     */
    userCoinsDataDELETE(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/UserCoinsData/{Id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserCoinsDataDELETE(_response);
        });
    }

    protected processUserCoinsDataDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    userCoinsDataPUT(id: string, body: UserCoinsData | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserCoinsData/{Id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserCoinsDataPUT(_response);
        });
    }

    protected processUserCoinsDataPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    userCoinsDataPOST(body: UserCoinsData | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserCoinsData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserCoinsDataPOST(_response);
        });
    }

    protected processUserCoinsDataPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CoinData implements ICoinData {
    mongoId?: string | undefined;
    id?: string | undefined;
    symbol?: string | undefined;
    name?: string | undefined;
    image?: string | undefined;
    current_price?: number;
    market_cap?: number;
    market_cap_rank?: number;
    total_volume?: number | undefined;
    price_change_percentage_24h?: number;
    last_updated?: Date;
    ingestionDate?: Date;

    constructor(data?: ICoinData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mongoId = _data["mongoId"];
            this.id = _data["id"];
            this.symbol = _data["symbol"];
            this.name = _data["name"];
            this.image = _data["image"];
            this.current_price = _data["current_price"];
            this.market_cap = _data["market_cap"];
            this.market_cap_rank = _data["market_cap_rank"];
            this.total_volume = _data["total_volume"];
            this.price_change_percentage_24h = _data["price_change_percentage_24h"];
            this.last_updated = _data["last_updated"] ? new Date(_data["last_updated"].toString()) : undefined as any;
            this.ingestionDate = _data["ingestionDate"] ? new Date(_data["ingestionDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): CoinData {
        data = typeof data === 'object' ? data : {};
        let result = new CoinData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mongoId"] = this.mongoId;
        data["id"] = this.id;
        data["symbol"] = this.symbol;
        data["name"] = this.name;
        data["image"] = this.image;
        data["current_price"] = this.current_price;
        data["market_cap"] = this.market_cap;
        data["market_cap_rank"] = this.market_cap_rank;
        data["total_volume"] = this.total_volume;
        data["price_change_percentage_24h"] = this.price_change_percentage_24h;
        data["last_updated"] = this.last_updated ? this.last_updated.toISOString() : undefined as any;
        data["ingestionDate"] = this.ingestionDate ? this.ingestionDate.toISOString() : undefined as any;
        return data;
    }
}

export interface ICoinData {
    mongoId?: string | undefined;
    id?: string | undefined;
    symbol?: string | undefined;
    name?: string | undefined;
    image?: string | undefined;
    current_price?: number;
    market_cap?: number;
    market_cap_rank?: number;
    total_volume?: number | undefined;
    price_change_percentage_24h?: number;
    last_updated?: Date;
    ingestionDate?: Date;
}

export class UserAuthData implements IUserAuthData {
    id?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    name?: string | undefined;
    createdAt?: Date;

    constructor(data?: IUserAuthData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.name = _data["name"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): UserAuthData {
        data = typeof data === 'object' ? data : {};
        let result = new UserAuthData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["password"] = this.password;
        data["name"] = this.name;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IUserAuthData {
    id?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    name?: string | undefined;
    createdAt?: Date;
}

export class UserCoinsData implements IUserCoinsData {
    id?: string | undefined;
    userId?: string | undefined;
    coinId?: string | undefined;

    constructor(data?: IUserCoinsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.coinId = _data["coinId"];
        }
    }

    static fromJS(data: any): UserCoinsData {
        data = typeof data === 'object' ? data : {};
        let result = new UserCoinsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["coinId"] = this.coinId;
        return data;
    }
}

export interface IUserCoinsData {
    id?: string | undefined;
    userId?: string | undefined;
    coinId?: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}